= Getting Started
In this section we're going to build an example application to cover some the most important concepts
and features of HellHound.

In order to continue with this section you need to have https://leiningen.org/[Leiningen] setup in your
box.

The final application is available at https://github.com/lxsameer/hellhound_examples[this github repository] and
under the `getting-started` namespace.

== Before start
The aim of this tutorial is to given you a rough overview about the *HellHound* systems. In order to continue
with this tutorial you should know about http://clojure.org/[clojure] and https://leiningen.org/[Leiningen].

== A little bit of theory
In order to have easier time reading this tutorial, I'm going to give you a brief introduction about some of the
concepts we're going to use in this tutorial. You can read more about each of these concepts in more details later
in their own sections.

* *System*:
    It's a hashmap describing our application system. Basically how it should work. <<systems, Learn More.>>

* *Component*:
  A system is create by a set of components. You can think of a component as a unix command or a function ( they
are more than a function though ). Just like a unix command each component has a input and output. <<components, Learn More>>

* *Workflow*: A workflow is a graph like data structure which defines the data flow of the system. Simply describes how to pipe
the output of a component to input of another component.<<workflow, Learn More>>

== What do we want to build ?
In order to gain an overview of HellHound systems we're going to build a real world application together. In this
example we're going to create a simple web proxy application which gets a domain name and a port number, setup a
webserver to serve the content of the given domain name and serve it locally.

*HellHound is library to create data pipelines.* Basically data pipelines are suitable for stream processing and
those use cases which involve with data streams. *But I chose the proxy use case intentionally to demonstrate
the usage of HellHound for a use case which is not a case of stream processing by default.*

== Tackle the problem
For this specific usage case web need to spin up a webserver which listens to a port for any HTTP URL and contructs new
requests from the incoming requests with different host ( the remote host ) and sent them to the actual host and response
back to user with the reponses fetch from the remote host.

So we're going to create a system hashmap with two component. A `webserver` component and a `loader` component. As the name
suggests `webserver` component should be responsible for getting the user requests and serving responses to the user. The
`loader` component should fetch the url content from the remote host. In this system we want to connect the output of
`webserver` to the input of `loader` and connect the output of `loader` to input of `webserver`. So we're going to end
up with a closed system.

Now let's get our feet wet.


== Installation

Add *HellHound* to your dependencies as follow:

[source,clojure]
----
[codamic/hellhound "1.0.0-alpha3"]
----

`codamic/hellhound` is a meta package which automatically install serveral HellHound libraries like `codamic/hellhound.core`
and `codamic/hellhound.http`. So your can only install an specific library that you need instead of using `codamic/hellhound`.
For instance you might not need the `codamic/hellhound.i18n` library or `codamic/hellhound.http` so you can just install
`codamic/hellhound.core`. Systems are part of `codamic/hellhound.core` artifact.

== Components
Lets start with <<components, components>> creation. HellHound's components are just hashmaps. Simple, good old hashmaps.
Any component map should contains at least three keys, `:hellhound.component/name`, `:hellhound.component/start-fn` and
`:hellhound.component/stop-fn`. The value of the `:hellhound.component/name` key should be a namespaced keyword which is
the component name. We use this name to refer to the component later in our system configuration. the value  of
`:hellhound.component/start-fn` should be function that takes two arguments. The first argument is the component hashmap
itself and the second argument is another hashmap which is called context map (In order to learn more about components
in details, please checkout the <<components, components section of this documentation>>). The main logic of the component
goes into this function. It should return a component map again. The `:hellhound.component/stop-fn` function is similar
to `start-fn` but accept only one argument which is the component map itself. This function is responsible for tearing down
the logic of the component and do the clean up. For example, close the connection which has been opened on `start-fn` or similar
stuff.

Ok, It's time to write some code. Let's start with a really basic component skeleton for the `webserver` component.
Check out the following code.

[source,clojure,linums]
.Basic skeleton for a component
----
(ns getting-started.proxy.components.web
  (:require [hellhound.component :as component])) <1>

(defn start-fn   <2>
  [this context]
  this)

(defn stop-fn    <3>
  [this]
  this)

(defn factory   <4>
  []
  (component/make-component ::server start-fn stop-fn)) <5>
----
<1> In order to use `make-component` function we need the `hellhound.component` ns.
<2> <<_component_start_fn,start-fn>> is the entry point to each component logic. Simply think of it
    as the place where you have to implement the logic behind your component. In this case our `start-fn`
    does nothing.
<3> <<_component_start_fn,start-fn>> is responsible for component termination logic, mostly cleanup. For instance,
    closing a socket, flushing data do disk and so on.
<4> Factory function is a simple function to create instances of our component with different configuration. In this
    case we just creates a fix component map. Nothing special.
<5> `make-component` function is just a shortcut function to create the component map easily. We can replace it by
    the actual hashmap definition of the component. We passed `::server` as the first argument to this function which
    is the name of our component. Component's name should be namespaced keyword.

Almost all of the components that you may encounter or create, will have the same skeleton. Let's go over the basics of
a component again. Each component has a name which must be a namespaced keyword, a `start-fn` with holds the logic of the
component and gets two arguments, the component map itself and a context map, and should return a component map, a `stop-fn`
that gets a component map and holds the termination logic. Every component has an input stream and an output stream defined
in their component-map. There are more details about components which you can read in <<components, components section>>.

HellHound created around and shares similar ideas as <<_the_unix_philosophy,unix philosophy>>. Components are isolated
unix of execution which read data from their input, process the data and write the result to the output. System makes a
data pipeline by pipeing IO of different components to one another. You'll learn more about this concept later on this
documentation.

Now that we setup a very basic component and we have better understanding about component concept. let's focus on the
webserver logic and create a real world webserver component.

[source,clojure,linums]
.Web server component.
----
include::https://raw.githubusercontent.com/Codamic/hellhound_examples/master/src/clj/getting_started/proxy/components/web.clj[]
----
<1> Namespace definition. As you can see we orginized the `web` component under `getting-started.proxy.components`
    namespace. It is a good practice to store all of your components under the same parent namespace.

<2> We're going to use the awesome http://aleph.io(Aleph) library to build our webserver. HellHound depends on this
    library by default (If we use the `codamic/hellhound` or `codamic/hellhound.http` artifact).

<3> `manifold.stream` library provides a very robust stream abstraction. Component's IO build around this abstraction
    and we need to use this library to work with component's IO. HellHound depends on the `manifold` library, so there's
    no need to add it explicitly to your dependencies.

<4> `manifold.deferred` library provides an abstraction around promises and futures, and aleph webserver uses them as
    async responses.

<5> The return value of this function is in fact the ring handler which we want to use to handle the incoming requests.
    The two paramter of `handler` function are the `input` and `output` of the webserver component.

<6> Before we return the actual ring handler, we need to setup a consumer for incoming data from the input stream.
    The basic idea is to treat any incoming data from the `input` stream of webserver component as a response and
    return the response to the user. Alph support async responses using deferreds, So by returning a deferred
    from *(8)* alph send back the response as soon as the deferred realised. In our consumer we just extract the same
    deferred value from the incoming map ( any incoming value is a hashmap and we placed the deferred into it in *(9)*)
    and resolve it the response map that again extracted from the same hashmap.

<7> The actual ring handler that receives the HTTP request hashmap (`req`).

<8> Created a deferred value to use as the response and pass it through the pipeline.

<9> Simply create a hashmap containing `:request` and `:response-deferred` with the corresponding values and put the
    hashmap into the webserver output stream (send it down to the pipeline). Then, return the created deferred so
    alph can return the reponse to user as soon as the response deferred realise.

<10> Receives a port number and return an anonymous function to be used as a start function for webserver component.
     It passes the given port number to the `start-server` function of aleph.

<11> `hellhound.component/io` function is a helper function which returns a vector in form of `[input output]` of
     the IO streams of the given component.

<12> Starts the aleph webserver. As you can see we passed the input and output of the component to `handler` fn.
     We assigned the returned value of `start-server` to a key in component map so we can close it later.

<13> `stop-fn` of the webserver component.

<14> Stop the aleph server by calling `.close` on the server object which we assigned to `:server` in the `start-fn`.

<15> Remove the `:server` key to get back to the initial state.

<16> Desctruct the port number from the given `config` map.

<17> Create and return a component map for with the name of `::server`.


== System

== Workflow

== Version 2.0
